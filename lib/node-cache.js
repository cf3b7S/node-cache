// Generated by CoffeeScript 1.8.0
var EventEmitter, NodeCache, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require('lodash');

EventEmitter = require('events').EventEmitter;

module.exports = NodeCache = (function(_super) {
  __extends(NodeCache, _super);

  function NodeCache(options) {
    this.options = options != null ? options : {};
    this._error = __bind(this._error, this);
    this._getValLength = __bind(this._getValLength, this);
    this._getKeyLength = __bind(this._getKeyLength, this);
    this._unwrap = __bind(this._unwrap, this);
    this._wrap = __bind(this._wrap, this);
    this._killCheckPeriod = __bind(this._killCheckPeriod, this);
    this._checkData = __bind(this._checkData, this);
    this.checkAllData = __bind(this.checkAllData, this);
    this.flushAll = __bind(this.flushAll, this);
    this.keys = __bind(this.keys, this);
    this.ttl = __bind(this.ttl, this);
    this.mdel = __bind(this.mdel, this);
    this.del = __bind(this.del, this);
    this.mget = __bind(this.mget, this);
    this.get = __bind(this.get, this);
    this.mset = __bind(this.mset, this);
    this.set = __bind(this.set, this);
    this.data = {};
    this.options = _.assign({
      ttl: 0,
      objectValueSize: 80,
      arrayValueSize: 40,
      stdTTL: 0,
      timeMultiplier: 1000,
      checkperiod: 600
    }, this.options);
    this.stats = {
      hits: 0,
      misses: 0,
      keys: 0,
      ksize: 0,
      vsize: 0
    };
    this.checkAllData();
  }

  NodeCache.prototype.set = function(key, value, ttl) {
    var keyExist, oldValue;
    if (ttl == null) {
      ttl = this.options.ttl;
    }
    keyExist = false;
    if (this.data[key]) {
      keyExist = true;
      oldValue = this._unwrap(this.data[key]);
      this.stats.vsize -= this._getValLength(oldValue);
    }
    this.data[key] = this._wrap(value, ttl);
    if (!keyExist) {
      this.stats.ksize += this._getKeyLength(key);
      this.stats.keys++;
    }
    this.stats.vsize += this._getValLength(value);
    return true;
  };

  NodeCache.prototype.mset = function(datas) {
    var data, key, ttl, value, _i, _len;
    for (_i = 0, _len = datas.length; _i < _len; _i++) {
      data = datas[_i];
      key = data.key, value = data.value, ttl = data.ttl;
      this.set(key, value, ttl);
    }
    return true;
  };

  NodeCache.prototype.get = function(key) {
    if (!_.isString(key)) {
      return null;
    }
    if ((this.data[key] != null) && this._checkData(key)) {
      this.stats.hits++;
      return this._unwrap(this.data[key]);
    } else {
      this.stats.misses++;
      return null;
    }
  };

  NodeCache.prototype.mget = function(keys) {
    var key;
    if (!_.isArray(keys)) {
      return [];
    }
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        _results.push(this.get(key));
      }
      return _results;
    }).call(this);
  };

  NodeCache.prototype.del = function(key) {
    if (!_.isString(key)) {
      return 0;
    }
    if (this.data[key] != null) {
      this.stats.ksize -= this._getKeyLength(key);
      this.stats.vsize -= this._getValLength(this._unwrap(this.data[key]));
      this.stats.keys--;
      delete this.data[key];
      this.emit('del', key);
      return 1;
    } else {
      this.stats.misses++;
      return 0;
    }
  };

  NodeCache.prototype.mdel = function(keys) {
    var delCount, key, _i, _len;
    if (!_.isArray(keys)) {
      return 0;
    }
    delCount = 0;
    for (_i = 0, _len = keys.length; _i < _len; _i++) {
      key = keys[_i];
      delCount += this.del(key);
    }
    return delCount;
  };

  NodeCache.prototype.ttl = function(key, ttl) {
    if (ttl == null) {
      ttl = this.options.stdTTL;
    }
    if ((this.data[key] != null) && this._checkData(key)) {
      this.data[key] = this._wrap(this._unwrap(this.data[key]), ttl);
      return true;
    } else {
      return false;
    }
  };

  NodeCache.prototype.keys = function() {
    return _.keys(this.data);
  };

  NodeCache.prototype.flushAll = function() {
    this._killCheckPeriod();
    this.data = {};
    this.stats = {
      hits: 0,
      misses: 0,
      keys: 0,
      ksize: 0,
      vsize: 0
    };
    this.checkAllData();
    this.emit('flush');
  };

  NodeCache.prototype.checkAllData = function() {
    var checkperiod;
    _.forEach(this.data, function(key) {
      return this._checkData(key);
    });
    if (this.options.checkperiod > 0) {
      checkperiod = this.options.checkperiod * this.options.timeMultiplier;
      this.checkTimeout = setTimeout(this.checkAllData, checkperiod);
    }
  };

  NodeCache.prototype._checkData = function(key) {
    var wrapValue;
    wrapValue = this.data[key];
    if (wrapValue.t !== 0 && wrapValue.t < Date.now()) {
      this.del(key);
      this.emit('expired', key, this._unwrap(wrapValue));
      return false;
    } else {
      return true;
    }
  };

  NodeCache.prototype._killCheckPeriod = function() {
    if (this.checkTimeout != null) {
      return clearTimeout(this.checkTimeout);
    }
  };

  NodeCache.prototype._wrap = function(value, ttl) {
    var livetime, now, ttlMultiplicator, wrapValue;
    if (ttl == null) {
      ttl = this.options.stdTTL;
    }
    now = Date.now();
    ttlMultiplicator = this.options.timeMultiplier;
    if (ttl === 0) {
      livetime = 0;
    } else {
      livetime = now + (ttl * ttlMultiplicator);
    }
    return wrapValue = {
      t: livetime,
      v: value
    };
  };

  NodeCache.prototype._unwrap = function(wrapValue) {
    if ((wrapValue != null ? wrapValue.v : void 0) != null) {
      return wrapValue.v;
    }
    return null;
  };

  NodeCache.prototype._getKeyLength = function(key) {
    return key.length;
  };

  NodeCache.prototype._getValLength = function(value) {
    if (_.isString(value)) {
      return value.length;
    } else if (this.options.forceString) {
      return JSON.stringify(value).length;
    } else if (_.isArray(value)) {
      return this.options.arrayValueSize * value.length;
    } else if (_.isNumber(value)) {
      return 8;
    } else if (_.isObject(value)) {
      return this.options.objectValueSize * _.size(value);
    } else {
      return 0;
    }
  };

  NodeCache.prototype._error = function(type, data, cb) {
    var error;
    if (data == null) {
      data = {};
    }
    error = new Error();
    error.name = type;
    error.errorcode = type;
    error.msg = "-";
    error.data = data;
    if (cb && _.isFunction(cb)) {
      cb(error, null);
    } else {
      return error;
    }
  };

  return NodeCache;

})(EventEmitter);

//# sourceMappingURL=node-cache.js.map
